Этот файл — README.md к лабораторной работе №3 по Python. Работа довольно большая и объединяет сразу несколько тем, которые мы проходили: рекурсия, сортировки, структуры данных (в частности, стек) и измерение времени выполнения алгоритмов. По сути, это практическая сводка по всему материалу, который понадобился для зачёта.

## Структура проекта

### 1. Папка **src** — основная логика программы

Здесь находятся все файлы, которые участвуют в выполнении лабораторной работы:

- **main.py** — главный файл, который запускает программу.
  Пользователь через него взаимодействует с функциями, сортировками, стеками и бенчмарками.
  Здесь же реализован диалог с пользователем, выбор стека, ввод массивов и вывод результатов.

- **funcs.py** — набор базовых функций:
  - `factorial` — классический итеративный факториал;
  - `factorial_recursive` — факториал через рекурсию;
  - `fib` — итеративный Фибоначчи;
  - `fibo_recursive` — рекурсивный Фибоначчи.

  Эти функции используются в начале программы, чтобы продемонстрировать различие подходов (рекурсия vs цикл).

- **sorts.py** — реализация различных алгоритмов сортировки:
  - `bubble_sort` — пузырьковая сортировка (самая простая);
  - `quick_sort` — быстрая сортировка (разделение по опорному элементу);
  - `counting_sort` — сортировка подсчётом для целых чисел, включая отрицательные;
  - `radix_sort` — разрядная сортировка (также поддерживает отрицательные числа);
  - `bucket_sort` — корзинная сортировка для чисел из диапазона [0, 1);
  - `heap_sort` — пирамидальная сортировка через max-heap.

  Каждый алгоритм реализован вручную, без использования встроенной функции `sorted`.

- **Stack_node.py** — реализация стека через связный список.
  Используется свой класс `Node`, где каждый узел содержит значение и ссылку на следующий узел.
  Подходит, если нужно понять, как работает структура без списков Python.

- **Staсk_list.py** — стек на базе обычного Python-списка.
  Самая компактная и понятная реализация.

- **Stack_queue.py** — стек через две очереди (`base_q` и `extra_q`).
  Здесь используется идея пересыпания элементов между очередями так, чтобы сохранялся принцип LIFO.

Во всех трёх стеках есть метод `min()`, который возвращает минимальный элемент в стеке за O(1) времени. Это реализовано через дополнительный список минимумов.

- **Benchmarks.py** — вспомогательные функции для замеров:
  - `timeit_once(func, *args)` — измеряет время выполнения одной функции;
  - `benchmark_sorts(arrays, algos)` — для группы массивов и группы сортировок возвращает таблицу времени выполнения.

---

### 2. Папка **tests** — тесты на pytest

Здесь находятся тесты на все ключевые части лабораторной работы:

- `test_funcs.py` — тесты на факториалы и Фибоначчи;
- `test_sorts.py` — тесты на все сортировки;
- `test_stacks.py` — проверка всех трёх реализаций стека, включая ошибки при обращении к пустому стеку;
- `test_benchmarks.py` — тесты на корректность структуры данных, которые возвращают бенчмарки.

Все тесты можно запустить командой `pytest -v`.

---

### 3. Остальные файлы

- `.gitignore` — перечень файлов, которые не должны попадать в git.
- `.pre-commit-config.yaml` — конфигурация хуков для автоформатирования, проверки файла и т.п.
- `pyproject.toml` — настройки проекта (для pytest, black и т.д.).
- `requirements.txt` — зависимости (pytest, black и т.п.).
- `uv.lock` — файл блокировки зависимостей.

---

## Подробное описание модулей

### funcs.py

Используется для демонстрации рекурсии и сравнения с итеративными версиями.
Функции небольшие, но они показывают различие подходов: стек вызовов, базовый случай, потеря производительности при глубокой рекурсии и т.д.

### sorts.py

В этой части реализованы алгоритмы разных уровней сложности — от простейшего пузырька до пирамидальной и разрядной сортировки.

Каждая сортировка работает «как на лекции», без встроенного `sorted`.
Некоторые сортировки имеют ограничения:

- `counting_sort` и `radix_sort` — **только для целых чисел**;
- `bucket_sort` — только для **float в диапазоне [0, 1)**.

Все сортировки тестируются в начале программы (по одной демонстрации каждой).

### Реализация стеков

Стеки сделаны в трёх вариантах исключительно в учебных целях — чтобы сравнить структуры данных и разные способы реализации одной и той же логики.

Везде поддерживаются операции:

- push
- pop
- peek
- len
- is_empty
- min

При этом метод `min()` работает за константное время, потому что параллельно ведётся стек минимумов.

### Benchmarks

Бенчмарки позволяют посмотреть, насколько быстро работают разные сортировки на разных массивах.
Сначала пользователь вводит название массива и сам массив, либо формирует его автоматически.
Потом программа выводит таблицу вида:

```
Массив_A:
    Bubble Sort: 0.0042
    Quick Sort: 0.0008
    Heap Sort: 0.0011
```

Это удобно для сравнения алгоритмов «вживую».

---

## Как работает программа (main.py)

Программа выстроена последовательно:

1. Пользователь вводит число `n`.
   На экран выводятся значения факториала и числа Фибоначчи (как итеративные, так и рекурсивные версии).

2. Далее демонстрируется работа всех шести сортировок на случайных данных.

3. Затем пользователь может выбрать один из трёх стеков и вручную протестировать его через набор команд:
   `push`, `pop`, `peek`, `is_empty`, `min`, `len`.

4. После этого программа предлагает ввести несколько массивов и выводит бенчмарки всех сортировок.

Оболочка обрабатывает большинство некорректных вводов:
нечисловые значения, повторные названия, пустые массивы и т.д.

---

## Запуск программы

```
python src/main.py
```

## Запуск тестов

```
pytest -v
```

---

## Особенности и ограничения

- `counting_sort` и `radix_sort` — только для целых чисел.
- `bucket_sort` — только для вещественных чисел в диапазоне [0, 1).
- При очень больших диапазонах (например, `[-10**12, 10**12]`) сортировка подсчётом может вызвать `MemoryError`. Это нормальное поведение.

---
